// Auto-generated by: python scripts/artisan2.py actions make-micsapi
// This is a static template — safe to regenerate (logic does not change per-spec).

import type { Paths, PathsWithMethod } from "./paths.gen";

// ---------------------------------------------------------------------------
// Token Store
// ---------------------------------------------------------------------------

export const tokenStore = {
  getAccessToken(): string | null {
    return localStorage.getItem("mics_access_token");
  },
  getRefreshToken(): string | null {
    return localStorage.getItem("mics_refresh_token");
  },
  setTokens(access: string, refresh: string) {
    localStorage.setItem("mics_access_token", access);
    localStorage.setItem("mics_refresh_token", refresh);
  },
  clear() {
    localStorage.removeItem("mics_access_token");
    localStorage.removeItem("mics_refresh_token");
  },
};

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

let _config = { baseUrl: "" };

function configure(opts: { baseUrl: string }) {
  _config = { ..._config, ...opts };
}

// ---------------------------------------------------------------------------
// Core fetch with auth + auto-refresh
// ---------------------------------------------------------------------------

let _refreshPromise: Promise<boolean> | null = null;

async function _tryRefresh(): Promise<boolean> {
  const refreshToken = tokenStore.getRefreshToken();
  if (!refreshToken) return false;

  try {
    const res = await fetch(`${_config.baseUrl}/api/v1/auth/refresh`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh_token: refreshToken }),
    });
    if (!res.ok) {
      tokenStore.clear();
      return false;
    }
    const data = await res.json();
    tokenStore.setTokens(data.access_token, data.refresh_token);
    return true;
  } catch {
    tokenStore.clear();
    return false;
  }
}

function _interpolatePath(
  path: string,
  pathParams?: Record<string, string | number>,
): string {
  if (!pathParams) return path;
  let result = path;
  for (const [key, value] of Object.entries(pathParams)) {
    result = result.replace(`{${key}}`, encodeURIComponent(String(value)));
  }
  return result;
}

function _buildQueryString(query?: Record<string, unknown>): string {
  if (!query) return "";
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) continue;
    if (Array.isArray(value)) {
      for (const v of value) {
        params.append(key, String(v));
      }
    } else {
      params.append(key, String(value));
    }
  }
  const qs = params.toString();
  return qs ? `?${qs}` : "";
}

interface FetchApiOpts {
  method: string;
  body?: unknown;
  path?: Record<string, string | number>;
  query?: Record<string, unknown>;
  headers?: Record<string, string>;
}

async function fetchApi(
  urlPath: string,
  opts: FetchApiOpts,
): Promise<unknown> {
  const url =
    _config.baseUrl +
    _interpolatePath(urlPath, opts.path) +
    _buildQueryString(opts.query);

  const headers: Record<string, string> = { ...opts.headers };
  const accessToken = tokenStore.getAccessToken();
  if (accessToken) {
    headers["Authorization"] = `Bearer ${accessToken}`;
  }

  let fetchOpts: RequestInit = { method: opts.method, headers };
  if (opts.body !== undefined) {
    if (opts.body instanceof FormData) {
      fetchOpts.body = opts.body;
      // Don't set Content-Type — browser sets multipart boundary
    } else {
      headers["Content-Type"] = "application/json";
      fetchOpts.body = JSON.stringify(opts.body);
    }
  }

  let res = await fetch(url, fetchOpts);

  // Auto-refresh on 401
  if (res.status === 401 && tokenStore.getRefreshToken()) {
    if (!_refreshPromise) {
      _refreshPromise = _tryRefresh().finally(() => {
        _refreshPromise = null;
      });
    }
    const refreshed = await _refreshPromise;
    if (refreshed) {
      // Retry with new token
      const newToken = tokenStore.getAccessToken();
      if (newToken) {
        headers["Authorization"] = `Bearer ${newToken}`;
      }
      fetchOpts = { ...fetchOpts, headers };
      res = await fetch(url, fetchOpts);
    }
  }

  if (!res.ok) {
    let detail: string;
    try {
      const errBody = await res.json();
      detail = errBody.detail || errBody.message || res.statusText;
    } catch {
      detail = res.statusText;
    }
    throw new Error(detail);
  }

  // 204 No Content
  if (res.status === 204) return undefined;

  return res.json();
}

// ---------------------------------------------------------------------------
// Auto-store tokens on login/refresh responses
// ---------------------------------------------------------------------------

function _autoStoreTokens(path: string, data: unknown) {
  if (
    (path === "/api/v1/auth/login" || path === "/api/v1/auth/refresh") &&
    data &&
    typeof data === "object" &&
    "access_token" in data &&
    "refresh_token" in data
  ) {
    const d = data as { access_token: string; refresh_token: string };
    tokenStore.setTokens(d.access_token, d.refresh_token);
  }
}

// ---------------------------------------------------------------------------
// Typed method helpers
// ---------------------------------------------------------------------------

// Extract the operation shape for a given path + method
type Op<P extends keyof Paths, M extends string> = M extends keyof Paths[P]
  ? Paths[P][M]
  : never;

// Build the options bag from an operation shape — preserves optionality of query/body
type MethodOpts<O> = Pick<O, ("path" | "query" | "body") & keyof O>;

// If MethodOpts is empty or all-optional, allow calling with no argument
type HasRequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];
type OptionalIfEmpty<T> = HasRequiredKeys<T> extends never ? [opts?: T] : [opts: T];

async function _typed<P extends keyof Paths, M extends string>(
  method: M,
  path: P,
  ...[opts]: OptionalIfEmpty<MethodOpts<Op<P, M>>>
): Promise<Op<P, M> extends { response: infer R } ? R : unknown> {
  const o = (opts ?? {}) as Record<string, unknown>;
  const data = await fetchApi(path as string, {
    method: method.toUpperCase(),
    path: o.path as Record<string, string | number> | undefined,
    query: o.query as Record<string, unknown> | undefined,
    body: o.body,
  });
  _autoStoreTokens(path as string, data);
  return data as never;
}

// ---------------------------------------------------------------------------
// Public API object
// ---------------------------------------------------------------------------

export const mycsapi = {
  configure,
  tokenStore,

  get<P extends PathsWithMethod<"get">>(
    path: P,
    ...opts: OptionalIfEmpty<MethodOpts<Op<P, "get">>>
  ) {
    return _typed("get", path, ...(opts as [never]));
  },

  post<P extends PathsWithMethod<"post">>(
    path: P,
    ...opts: OptionalIfEmpty<MethodOpts<Op<P, "post">>>
  ) {
    return _typed("post", path, ...(opts as [never]));
  },

  put<P extends PathsWithMethod<"put">>(
    path: P,
    ...opts: OptionalIfEmpty<MethodOpts<Op<P, "put">>>
  ) {
    return _typed("put", path, ...(opts as [never]));
  },

  patch<P extends PathsWithMethod<"patch">>(
    path: P,
    ...opts: OptionalIfEmpty<MethodOpts<Op<P, "patch">>>
  ) {
    return _typed("patch", path, ...(opts as [never]));
  },

  delete<P extends PathsWithMethod<"delete">>(
    path: P,
    ...opts: OptionalIfEmpty<MethodOpts<Op<P, "delete">>>
  ) {
    return _typed("delete", path, ...(opts as [never]));
  },

  /** Escape hatch for untyped/custom calls (uploads, RPC, etc.) */
  fetch: fetchApi,
};
