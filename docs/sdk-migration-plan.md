# Plan: SDK Migration

**Goal:** Replace all data fetching logic that uses the legacy `apiBackendAction` with direct calls to the new, type-safe SDK generated by `@hey-api/openapi-ts`.

**Status File:** `docs/sdk-migration-plan.md`

---

#### Phase 1: Foundational Pages (Get the core user flow working)

-   [x] **Authentication:** `src/pages/Auth.tsx` - *Completed*
    -   Replace `apiBackendAction("auth.login", ...)` with `authService.login(...)`.
    -   Update session checking to use the `useAuth` context.
-   [x] **Main Dashboard:** `src/pages/Index.tsx` - *Completed*
    -   Replace `apiBackendAction("incidentes.list", ...)` with `getIncidentesApiV1IncidentesGet(...)`.
    -   Update `IncidenteSchema` type import to point to `@/generated_sdk/types.gen`.
-   [x] **Client Management:** `src/pages/mostrador/Incidentes.tsx` - *Completed*
    -   Replace `apiBackendAction("clientes.list", ...)` with `listClientesApiV1ClientesGet(...)`.
    -   Update any client-related type imports.
-   [x] **Client Detail View:** `src/pages/DetalleCliente.tsx` - *Completed*
    -   Replace `apiBackendAction("clientes.get", ...)` with `getClienteApiV1ClientesClienteIdGet(...)`.
    -   Update client and related type imports.
-   [x] **Client Unified View:** `src/pages/ClientesUnificado.tsx` - *Completed*
    -   Resolved API response destructuring for `listClientesApiV1ClientesGet`.

#### Phase 2: Core Incident Workflow

-   [x] **Incident Detail View:** `src/pages/DetalleIncidente.tsx` - *Completed*
    -   This component is now implemented using the SDK.
-   [x] **Active Incidents Context:** `src/contexts/ActiveIncidentsContext.tsx` - *Completed*
    -   Replaced legacy `apiBackendAction` calls with `getMyAssignedIncidentesApiV1IncidentesMisAsignacionesGet` and `getProductoApiV1ProductosProductoIdGet`.
-   [ ] **New Incident Form:** `src/pages/NuevoIncidente.tsx`
    -   Replace `apiBackendAction("clientes.search", ...)` with `listClientesApiV1ClientesGet(...)`.
    -   Replace `apiBackendAction("incidentes.create", ...)` with `createIncidenteApiV1IncidentesPost(...)`.
    -   Update all related type imports.

#### Phase 3: Cleanup and Finalization

-   [ ] **Component-by-Component Sweep:**
    -   Go through all remaining pages and components that still import `apiBackendAction` or types from `@/generated/**`.
    -   Prioritize by user role/section (e.g., `taller`, `logistica`, etc.).
-   [ ] **Remove Legacy Facade:**
    -   Once no files import from `apiBackendAction`, delete `src/lib/api-backend.ts` and `src/lib/api-registry.ts`.
-   [ ] **Remove Old Generated Types:**
    -   Delete the entire `src/generated/**` directory.
-   [ ] **Final Review:**
    -   Run a full project search for `apiBackendAction` and `src/generated/` to ensure no remnants are left.
    -   Run the application and perform a full regression test of all features.

---

### Best Practices / Lessons Learned from SDK Migration

During the migration to the `@hey-api/openapi-ts` generated SDK, we observed an important pattern regarding API response handling:

*   **Flattened Single-Status Responses:** When the generated client's configuration uses the default `responseStyle: 'fields'` (which returns `{ data, request, response }`), and an API endpoint has only a single successful HTTP status code (e.g., `200 OK`) defined in its OpenAPI specification, the actual API payload is directly accessible via the `data` property of the response object.
*   **Example:** For an API call like `listClientesApiV1ClientesGet()`, even if its generated response type might conceptually suggest `response.data['200']`, the correct way to access the payload (e.g., `ClienteListOutput` containing `results` and `total`) is directly through `response.data`. For example:
    ```typescript
    const { data } = await listClientesApiV1ClientesGet(...);
    const { results, total } = data; // Directly access results and total from 'data'
    ```
*   **Runtime Verification:** Always verify the actual structure of the API response at runtime (e.g., using `console.log`) if destructuring errors or unexpected `undefined` values occur. The generated types might sometimes suggest a more nested structure than what the client library actually provides in practice due to its internal flattening logic.
